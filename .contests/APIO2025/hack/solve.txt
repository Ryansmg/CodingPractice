1. (8 points) n ≤ 500 000
2. (17 points) n ≤ 1 000 000

1 <= n <= 10^9
q <= 110000
이어야 만점

일단 최대 백만 개의 수를 넣어볼 수 있으니까


n <= 1 000 000
이면
1~1000000 을 넣고
충돌이 0개면 1 000 000
1개면 999 999
이거를
어케계산하지
파라해주면될듯

아니
시발
백만에
nlogn 인데
TLE인건
대체뭐임

내25점내놔;;
50만이면 도나봄
맞네
아니시발
이게맞아요?

약간의 런전처를 통해 25점을 획득
즐겁다.

그래서 백만 nlogn은 왜안돈거임

근데풀테는어케품?

다른 문제들이 다 풀기 싫게 생겼기 때문에

이거 풀테를 좀 고민해보도록 합시다.

흠.

일단 N <= 1 000 000일 때 처럼 1~10억을 넣는 풀이는
될 리가 없기 때문에
다른 방안을 찾아야 할 듯

예를 들어서
N = 155715571이면
어케찾음?
이때 해시 충돌이 발생하려면
넣은 자연수 % N 이 겹쳐야 하잖아

소인수분해하는 방안을 생각해 봤는데

#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<bool> isPrime(1'000'000'010, true);
    isPrime[1] = false;
    long long cnt = 0;
    for(long long i = 2; i <= 1'000'000'000; i++) {
        if(!isPrime[i]) continue;
        cnt++;
        // cout << i << endl;
        for(long long j = i + i; j <= 1'000'000'000; j+=i) {
            isPrime[j] = false;
        }
    }
    cout << "cnt: " << cnt << endl;
}

1'000'000'000 이하의 소수가 총 50847534개라서
소인수분해는 좀 쉽지 않을듯

아닌가 되나

약간

폴라드 로에 이거 섞어서

아니 근데 애초에

말이 되는 소리를 해야지;

N = 1000000이면
2의 배수인 걸 어떻게 찾을 건데

븅

ㅈㄴ어렵네
흠

1 <= n <= 10^9
q <= 110000
이어야 만점

11만 번?
:thonking:
:blobthinkingfast:
:blobfearful:
대체왜지
\sqrt(1'000'000'000) = 31623
log2(1'000'000'000) = 29.8974

만약에 n이 크고 해시값 충돌을 일으키지 못한다면
뭐 할 수 있는 게 없음
그니까
어떻게 해서든 일단 해시 충돌을 일으켜야 하는데
how
막 n이 15571557이면
어케함?
n이 10억이고
랜덤하게 1~10^18 중에 k개를 집어넣는다고 하면
그게 충돌할 리가 없단 말이지
뭔가 전략이 있어야 함

1과 1 + (2 * 3 * 5 * 7 * ... * 47 * ...)을 넣었을 때 충돌이 있다는 건
n이 2 또는 3 또는 5 또는 ... 또는 47이라는 것과 동치 아닌가?
왜냐하면 1 === 1 + (2 * 3 * ...) mod n이니까
2 * 3 * ... === 0 mod n
아 그러면
n이 2 * 3 * ...의 약수이다
와 동치구나
오..

10억 이하의 모든 소수에 대해서 확인해보려면 몇 개의 수가 필요한지를 세봄
25410364번이래요
shit

아 뭔가 될 거 같은데

만약에 N개의 수를 넣었을 때 충돌이 있다 치면
절반씩 나눠서 쿼리 날려보고 하면 되니까
log2(N)번만에 어떤 수에서 1하고 충돌이 있었는지를 알아낼 수 있음


근데 막 1e8 크기의 소수 같은 애들에서는 충돌을 어떻게 시키냐고
11만 번으로
흠ㅁㅁㅁㅁㅁㅁㅁㅁㅁ

v%n이 1~100인 경우는 잡아내기가 비교적 쉽단 말이지
1, ..., 100, v를 넣었을 때 충돌이 있는지를 보면 되니까


=====================

일단
N개의 수에 대해 뭔가 충돌이 있음!
=> 절반을 나눠서 l, r이라 하면
l 내의 충돌이 있는 경우 -> l에 대해서 수행
r -> r
없는 경우 -> r을 절반씩 나눠서 l과 충돌하는 부분을 찾고 l을 절반 나눠서 충돌하는 부분을 찾고를 반복
=> NlogN의 cost로 충돌하는 두 수를 찾을 수 있음
=> 정답은 abs(i-j)의 약수가 됨.

abs(i-j)의 약수는 최대 2^10개고 소수의 개수는 최대 31개니까, 서로 다른 소수는 최대 10개

각 소수에 대해서 몇 개나 포함되었는지를 구해 주면
여기서 사용되는 cost는 나이브하게 해도 대충 200 미만일거임
클리어

======================

그럼 어떻게 충돌을 시킬 것인가?
진짜어케함;;;;;
걍 존나
충돌하기를 바라고 N개를 넣어 봐?
근데 이러면 확률이 ㅈㄴ 낮잖아
ㅅㅂ
의외로 높을 수도
오?

해봤는데 4만 개를 넘진 않음
캬캬캬캬캬캬
짜러감

25점짜리 코드:

#include "hack.h"
#include <bits/stdc++.h>

using i64 = long long;
using namespace std;
#define forf(i, a, b) for(i64 i = a; i <= b; i++)
#define forr(i, a, b) for(i64 i = b; i >= a; i--)

vector<i64> x(1'000'000);
map<i64, i64> prv;

int hack(){
    if(prv.empty()) {
        prv.emplace(0, 1'000'000);
        prv.emplace(100'000, 900'000);
        prv.emplace(200'000, 800'000);
        prv.emplace(300'000, 700'000);
        prv.emplace(400'000, 600'000);
        prv.emplace(500'000, 500'000);
        prv.emplace(800'000, 400'000);
        prv.emplace(1'200'000, 300'000);
        prv.emplace(2'000'000, 200'000);
        prv.emplace(4'500'000, 100'000);
        prv.emplace(499'999'500'000, 1);
    }
    if(!x[0]) forf(i, 0, 999'999) x[i] = i+1;

    long long a = collisions(x);
    if(prv.find(a) != prv.end()) return prv[a];

    i64 r = (--prv.upper_bound(a))->second;
    i64 l = prv.upper_bound(a)->second;

    i64 ans = -1;
    for(; l <= r;) {
        i64 m = (l + r) / 2;
        vector<i64> cnt(m);
        i64 cans = 0;
        forf(i, 1, 1'000'000) cans += cnt[i%m]++;
        if(cans >= a) ans = m, l = m+1;
        else r = m-1;
    }

    prv.emplace(a, ans);

    return ans;
}

해봤는데 50점은 못 넘음

근데 모든 가능한 n에 대해 a[i] - a[j] = n을 만족하는 i, j가 있도록 구성할 수 있지 않을까?

31623 + 31623개만 있으면 되잖아
1, 2, ..., 31623, 31623 * 2, 31623 * 3, ..., 31623 * 31623

오
근데
998244353에 대해 379469라는 cost가 드네
왜지?
아
assert시발
안지웠네
븅

63.9점

캬캬캬캬

두 개의 수를 찾는 과정을 좀
최적화시킬 수 없나

있으니까 63.9점이겠지

concat(l, r)에 충돌이 있는 경우에 한해서

지금은

n * 3/4 + n/2 로 절반을 줄이고 있는데

ll, lr, rl, rr을 나눠 놓으면

최악의 경우에 n/2 + n/2 + n/2
더별로네
음

아
1, 2, ..., 31623, 31623 * 2, 31623 * 3, ..., 31623 * 31623

이면
collision(l), collision(r)이 0일 확률이 증가한다는 사실을 깨달음
shuffle을해보자
998244353 -> 142291

dma

더 많은 테스트케이스가 채점되었으나
똑같이 63.9점임

75 * log_50(1000000/110000-90000)이 얼마정도지?
75 * log_50(1000000/20000) = 75 * log_50(50) = 75
아하
걍 연속적인 점수구나

그럼 어케 또 또 63.9점이 나온 거지

findTwo(x)에서 x를 계속 셔플해주면
줄지 않을까
998244353 -> 221342
shit
sort를 해볼까
221353
시발;;

findTwo에서 l과 r에 collision이 없을 경우
원래는 걍 절반씩 줄여 가면서 한 번에
둘 다 절반 줄인 뒤에 findTwo(concat(l, r))을 호출하면 줄지 않을까
-> 284598

음
ㅅㅂㅋㅋ

1, 2, ..., 31623, 31623 * 2, 31623 * 3, ..., 31623 * 31623 << 을 최적화시켜줘야되나?

아니 일단
collision(l), collision(r)의 확률을 낮추는 건
x를 sort하면 됨
근데개큰문제는
확률을 높여야한다는거임;;;;;

아니시발
63246 * 2 = 126000점 정도까지는 받을 수 있을 거 같은데
개같은 !collision(l) && !collision(r) 경우 때문에
점수가안나오잖아!!

저러면

항상
1, 2, ..., 31623 내에서 충돌하거나
(1, 2, ..., 31623) / (31623 * 2, ..., 31623 * 31623) 에서 충돌한단 말이지
이걸 이용할 순 없나?

collision(r) 콜을 줄일 수 있으니까
31623이나 감소하네

998244353 189726
69.2점이 됨
야호
아 배민 안고 싶다
라나도안고싶다
:blobcomfort:

갑자기
비가 오네
우산 없는데
시발
ㅁㄴㅇㄻㄴㅇㄻㄴㅇㄻㄴㅇ

트온선배팬이에요

이거를
모든 a[i]-a[j]가 distinct 하도록 a를 잘 구성하면
만점이 나오나?

런전처를존나열심히하기
말고 생각이 안 나는데

팩트는 5분밖에안남았다는거임

collisions의 리턴값을 이용하지 않았다는 사실을 깨달음
bool(collisions(x))만 썼고 값 그 자체는 안 씀
큰 변화는 없을 거 같긴 한데
더 줄일 수 있을 거 같긴 하다는 생각이 드네요
